#define DEBUG_BEFORE_AFTER 2
#define DEBUG_GRAYSCALE 3
#define DEBUG_SHADOWS 4
#define DEBUG_MIDTONES 5
#define DEBUG_HIGHLIGHTS 6
#define DEBUG_CHECK_ARRAYS 7
#define DEBUG_COL_BOOST_CHECK 8

#define TYPE_TOMB_MASK 1
#define TYPE_TOMB_MASK_DEBUG 2

varying float Time;
varying vec4 Color0;
varying vec2 TexCoord0;
varying vec4 RenderDataOut;
varying float ScaleOut;

varying float Active;
varying float Type; //type 1: tomb masks
varying float Variant; //for type 1: selected mask
varying float Debug; //shadersOn in lua
varying float Contrast;
varying float Lightness;
varying float Saturation;

varying vec3 RGBOut;

varying vec2 nBr;
varying vec2 nTl;

uniform sampler2D Texture0;

float distToLine(vec2 p1, vec2 p2, vec2 p)
{
    vec2 lineDir = p2 - p1;
    vec2 perpDir = vec2(lineDir.y, -lineDir.x);
    vec2 dirToPt1 = p1 - p;
    return abs(dot(normalize(perpDir), dirToPt1));
}

float plotLine(vec2 st, vec2 p1, vec2 p2, float e, float f, vec2 orBr, vec2 orTl)
{
    vec2 c = (nBr+nTl)/2.; //center
    vec2 orc = (orBr+orTl)/2.; // original center
    float scale = (nBr.x - c.x)/(orBr.x - orc.x);
    vec2 translate = c - orc;

    vec2 transP1 = c + (p1 - c + translate) * scale;
    vec2 transP2 = c + (p2 - c + translate) * scale;
    return pow( smoothstep( (e + f) * scale, e * scale,    distToLine(transP1, transP2, st)), 1.5);
}

//turn into equalized normalized coordinates, meaning the x axis stays the same,
//but the y axis is 1 where the x axis would be (in other words, as if the screen was square)
//circle center is already saved this way
vec2 equalizeNormVec(vec2 v)
{
    return vec2(v.x, v.y / RenderDataOut.x * RenderDataOut.y);
}

float plotCircle(vec2 st, vec2 cnt, float r, float f, vec2 orBr, vec2 orTl)
{
    vec2 stx = equalizeNormVec(st);

    vec2 c = (nBr+nTl)/2.; //center of screen
    vec2 orc = (orBr+orTl)/2.; // original center of screen, not to be confused with Shrek's species
    float scale = (nBr.x - c.x)/(orBr.x - orc.x);
    vec2 translate = equalizeNormVec(c - orc);
    vec2 eqc = equalizeNormVec(c);

    vec2 transCnt = eqc + (cnt - eqc + translate) * scale;
    return pow( smoothstep( (r + f) * scale, r * scale,    distance(transCnt, stx)), 1.5);
}

float getTombMask(vec2 st, int IVariant, vec2 Br, vec2 Tl);

//Original room boundaries for tomb masks, used in scaling
const vec2 Tl = vec2(0.14791665971279, 0.16296295821667);
const vec2 Br = vec2(0.85208332538605, 0.83703702688217);
const vec2 EdgeOffset = vec2(0.04);
const vec2 EdgeFeather = vec2(0.02);

const vec3 FullW = vec3(1.0);
const vec3 Grey = FullW * 0.5;
const vec3 W = vec3(0.2125, 0.7154, 0.0721); //Used for sRGB

const vec2 ZeroOne = vec2(0.,1.); //used for optimization

void main()
{
    if (Active < 0.0001) { //immediately exit if shaders off
        gl_FragColor = texture2D(Texture0, TexCoord0.xy);
    } else {
        int IType = int(Type);
        int IVariant = int(Variant);
        int IDebug = int(Debug);

        vec2 st = gl_FragCoord.xy/RenderDataOut.xy;
        if (Active > 0.0 && IType != 0 && IVariant != 0 
        && ( IDebug == TYPE_TOMB_MASK || (IDebug == DEBUG_BEFORE_AFTER && st.x > 0.5) || IDebug == DEBUG_GRAYSCALE) ) {
            vec3 Color = texture2D(Texture0, TexCoord0.xy).rgb;

            float avgRGB = dot(Color, W);

            if (IType == TYPE_TOMB_MASK || IType == TYPE_TOMB_MASK_DEBUG) { //Tomb masks
                float mask = getTombMask(st, IVariant, Br, Tl);

                vec2 eo = EdgeOffset * ScaleOut;
                vec2 ef = EdgeFeather * ScaleOut;
                vec2 edge1 = smoothstep(nTl - eo - ef, nTl - eo, st);
                vec2 edge2 = vec2(1.) - smoothstep(nBr + eo, nBr + eo + ef, st);

                mask *= edge1.x * edge1.y * edge2.x * edge2.y;

                mask *= Active;

                // Global Tint
                Color = mix(Color, Color * RGBOut, mask);

                //Saturation, from OpenGL Chapter 16
                vec3 intensity = vec3(avgRGB);
                Color = mix(intensity, Color, Saturation*mask+1.0);

                //Lightness
                Color = mix(Color, FullW, Lightness*mask);

                //Contrast
                Color = mix(Color, Grey, -Contrast*mask);

                if (IType == TYPE_TOMB_MASK_DEBUG) {
                    Color = mix(Color, FullW, mask);
                }
            }

            if (IDebug != DEBUG_GRAYSCALE)
                gl_FragColor = Color.rgbr*ZeroOne.yyyx+ZeroOne.xxxy;
            else
                gl_FragColor = vec4(vec3(dot(Color, W)), 1.0);
        } else {
            gl_FragColor = texture2D(Texture0, TexCoord0.xy);
        }
    }
}

//Constants were autogenerated, see core2
//Line Masks for tomb effect

const vec2 P1_1_L1 = vec2(0.16041666269302, 0.42037037014961);
const vec2 P1_1_L2 = vec2(0.86770832538605, 0.62407410144806);
const float Expansion1_1_L = 0.051894295960665;
const float Feather1_1_L = 0.13870289549232;

const vec2 P3_1_L1 = vec2(0.27187499403954, 0.1740740686655);
const vec2 P3_1_L2 = vec2(0.32499998807907, 0.77777779102325);
const float Expansion3_1_L = 0.040793284773827;
const float Feather3_1_L = 0.11709925532341;

const vec2 P3_2_L1 = vec2(0.63749998807907, 0.14444445073605);
const vec2 P3_2_L2 = vec2(0.69062501192093, 0.84074074029922);
const float Expansion3_2_L = 0.0051932209171355;
const float Feather3_2_L = 0.10856634145603;

const vec2 P8_1_L1 = vec2(0.62604165077209, 0.14444445073605);
const vec2 P8_1_L2 = vec2(0.33958333730698, 0.9037036895752);
const float Expansion8_1_L = 0.12051863223314;
const float Feather8_1_L = 0.19252078980207;

const vec2 P9_1_L1 = vec2(0.15000000596046, 0.4277777671814);
const vec2 P9_1_L2 = vec2(0.87708336114883, 0.5407407283783);
const float Expansion9_1_L = 0.067155696451664;
const float Feather9_1_L = 0.14003180712461;

const vec2 P9_2_L1 = vec2(0.45208331942558, 0.86851853132248);
const vec2 P9_2_L2 = vec2(0.60520833730698, 0.12222222238779);
const float Expansion9_2_L = 0.024725275114179;
const float Feather9_2_L = 0.10505658201873;

//Circle masks for tomb effect

const vec2 Cnt2_1_C = vec2(0.92083334922791, 0.053125001490116);
const float Radius2_1_C = 0.13944724202156;
const float Feather2_1_C = 0.43014255166054;

const vec2 Cnt4_1_C = vec2(0.32291665673256, 0.35208332538605);
const float Radius4_1_C = 0.032609317451715;
const float Feather4_1_C = 0.14046102389693;

const vec2 Cnt4_2_C = vec2(0.38229167461395, 0.32916668057442);
const float Radius4_2_C = 0.019150810316205;
const float Feather4_2_C = 0.13718597404659;

const vec2 Cnt5_1_C = vec2(0.49583333730698, 0.27604165673256);
const float Radius5_1_C = 0.098364435136318;
const float Feather5_1_C = 0.18393490463495;

const vec2 Cnt6_1_C = vec2(0.33541667461395, 0.34999999403954);
const float Radius6_1_C = 0.065260216593742;
const float Feather6_1_C = 0.16993507742882;

const vec2 Cnt7_1_C = vec2(0.703125, 0.18541666865349);
const float Radius7_1_C = 0.046689432114363;
const float Feather7_1_C = 0.14398107305169;

const vec2 Cnt10_1_C = vec2(0.38645833730698, 0.22708334028721);
const float Radius10_1_C = 0.03294038772583;
const float Feather10_1_C = 0.17021401226521;

float getTombMask(vec2 st, int IVariant, vec2 Br, vec2 Tl)
{
    float mask = 0.0;

    if (IVariant == 1) {
        mask += plotLine(st, P1_1_L1, P1_1_L2, Expansion1_1_L, Feather1_1_L, Br, Tl);
    } else
    if (IVariant == 2) {
        mask += plotCircle(st, Cnt2_1_C, Radius2_1_C, Feather2_1_C, Br, Tl);
    } else
    if (IVariant == 3) {
        mask += plotLine(st, P3_1_L1, P3_1_L2, Expansion3_1_L, Feather3_1_L, Br, Tl);
        mask += plotLine(st, P3_2_L1, P3_2_L2, Expansion3_2_L, Feather3_2_L, Br, Tl);
    } else
    if (IVariant == 4) {
        mask += plotCircle(st, Cnt4_1_C, Radius4_1_C, Feather4_1_C, Br, Tl);
        mask += plotCircle(st, Cnt4_2_C, Radius4_2_C, Feather4_2_C, Br, Tl);
    } else
    if (IVariant == 5) {
        mask += plotCircle(st, Cnt5_1_C, Radius5_1_C, Feather5_1_C, Br, Tl);
    } else
    if (IVariant == 6) {
        mask += plotCircle(st, Cnt6_1_C, Radius6_1_C, Feather6_1_C, Br, Tl);
    } else
    if (IVariant == 7) {
        mask += plotCircle(st, Cnt7_1_C, Radius7_1_C, Feather7_1_C, Br, Tl);
    } else
    if (IVariant == 8) {
        mask += plotLine(st, P8_1_L1, P8_1_L2, Expansion8_1_L, Feather8_1_L, Br, Tl);
    } else
    if (IVariant == 9) {
        mask += plotLine(st, P9_1_L1, P9_1_L2, Expansion9_1_L, Feather9_1_L, Br, Tl);
        mask += plotLine(st, P9_2_L1, P9_2_L2, Expansion9_2_L, Feather9_2_L, Br, Tl);
    } else
    if (IVariant == 10) {
        mask += plotCircle(st, Cnt10_1_C, Radius10_1_C, Feather10_1_C, Br, Tl);
    }

    return min(1.0, mask);
}
